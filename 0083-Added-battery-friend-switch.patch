From 98d08f4aab54beb77f24ce28a291f4b09c3c78a9 Mon Sep 17 00:00:00 2001
From: artas182x <artas182x@gmail.com>
Date: Sat, 12 Jul 2014 20:12:51 +0200
Subject: [PATCH 083/100] Added battery friend switch

---
 arch/arm/mach-omap2/omap2plus-cpufreq.c |  15 ++++-
 drivers/misc/Makefile                   |   1 +
 drivers/misc/battery_friend.c           | 103 ++++++++++++++++++++++++++++++++
 mm/page-writeback.c                     |  26 ++++++++
 4 files changed, 144 insertions(+), 1 deletion(-)
 create mode 100644 drivers/misc/battery_friend.c

diff --git a/arch/arm/mach-omap2/omap2plus-cpufreq.c b/arch/arm/mach-omap2/omap2plus-cpufreq.c
index 77e5924..a1e3fe4 100644
--- a/arch/arm/mach-omap2/omap2plus-cpufreq.c
+++ b/arch/arm/mach-omap2/omap2plus-cpufreq.c
@@ -73,6 +73,7 @@ static bool omap_cpufreq_ready;
 static bool omap_cpufreq_suspended;
 
 
+extern bool battery_friend_active;
 #define CONFIG_OMAP4430_CPU_OVERCLOCK
 #ifdef CONFIG_OMAP4430_CPU_OVERCLOCK
 
@@ -523,7 +524,19 @@ static void omap_cpu_early_suspend(struct early_suspend *h)
 	unsigned int cur;
 
 	mutex_lock(&omap_cpufreq_lock);
-	max_freq_cap = screen_off_max_freq;
+
+
+	
+		if (likely(battery_friend_active))
+{
+max_freq_cap = 600000;		
+}
+else
+{
+max_freq_cap = screen_off_max_freq;
+}
+
+
 		cur = omap_getspeed(0);
 		if (cur > max_freq_cap)
 			omap_cpufreq_scale(max_freq_cap, cur);
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 76c87c7..10d4277 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -77,3 +77,4 @@ obj-$(CONFIG_TSPDRV)		+= tspdrv/
 obj-$(CONFIG_LGE_MODEM_WATCHER)	+= modem_watcher.o
 obj-$(CONFIG_TS0710_MUX)	+= ts0710mux/
 obj-$(CONFIG_CACHE2DMANAGER)	+= cache-2dmanager/
+obj-y		+= battery_friend.o
diff --git a/drivers/misc/battery_friend.c b/drivers/misc/battery_friend.c
new file mode 100644
index 0000000..a2e7a25e
--- /dev/null
+++ b/drivers/misc/battery_friend.c
@@ -0,0 +1,103 @@
+/*
+ * Author: Artur Załęski (artas182x) <artas182x@gmail.com>
+ *
+ * Copyright 2014 artas182x
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kobject.h>
+#include <linux/sysfs.h>
+
+#include <linux/mutex.h>
+
+static DEFINE_MUTEX(battery_mutex);
+
+bool battery_friend_active __read_mostly = true;
+
+
+static ssize_t battery_friend_active_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", (battery_friend_active ? 1 : 0));
+}
+
+
+static ssize_t battery_friend_active_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int data;
+
+	if(sscanf(buf, "%u\n", &data) == 1) {
+		if (data == 1) {
+			battery_friend_active = true;
+		}
+		else if (data == 0) {
+			battery_friend_active = false;
+		}
+	} 
+
+
+	return count;
+}
+
+
+static struct kobj_attribute battery_friend_active_attribute = 
+	__ATTR(Battery_friend_active, 0666,
+		battery_friend_active_show,
+		battery_friend_active_store);
+
+
+
+static struct attribute *battery_friend_active_attrs[] =
+	{
+		&battery_friend_active_attribute.attr,
+		NULL,
+	};
+
+static struct attribute_group battery_friend_active_attr_group =
+	{
+		.attrs = battery_friend_active_attrs,
+	};
+
+static struct kobject *battery_friend_kobj;
+
+
+
+static int battery_friend_init(void)
+{
+	int sysfs_result;
+
+
+	battery_friend_kobj = kobject_create_and_add("battery_Friend", kernel_kobj);
+	if (!battery_friend_kobj) {
+		return -ENOMEM;
+        }
+
+	sysfs_result = sysfs_create_group(battery_friend_kobj,
+			&battery_friend_active_attr_group);
+
+        if (sysfs_result) {
+		kobject_put(battery_friend_kobj);
+	}
+	return sysfs_result;
+}
+
+static void battery_friend_exit(void)
+{
+
+	if (battery_friend_kobj != NULL)
+		kobject_put(battery_friend_kobj);
+}
+
+module_init(battery_friend_init);
+module_exit(battery_friend_exit);
diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index 955fe35..b50c121 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -35,6 +35,7 @@
 #include <linux/buffer_head.h>
 #include <linux/pagevec.h>
 #include <trace/events/writeback.h>
+extern bool battery_friend_active;
 
 /*
  * After a CPU has dirtied this many pages, balance_dirty_pages_ratelimited
@@ -139,6 +140,14 @@ static struct prop_descriptor vm_dirties;
 static int calc_period_shift(void)
 {
 	unsigned long dirty_total;
+	if (likely(battery_friend_active))
+	{
+	vm_dirty_ratio = 90;
+	}
+	else
+	{
+	vm_dirty_ratio = 70;
+	}
 
 	if (vm_dirty_bytes)
 		dirty_total = vm_dirty_bytes / PAGE_SIZE;
@@ -186,6 +195,14 @@ int dirty_ratio_handler(struct ctl_table *table, int write,
 		void __user *buffer, size_t *lenp,
 		loff_t *ppos)
 {
+	if (likely(battery_friend_active))
+	{
+	vm_dirty_ratio = 90;
+	}
+	else
+	{
+	vm_dirty_ratio = 70;
+	}
 	int old_ratio = vm_dirty_ratio;
 	int ret;
 
@@ -411,6 +428,15 @@ void global_dirty_limits(unsigned long *pbackground, unsigned long *pdirty)
 	unsigned long background;
 	unsigned long dirty;
 	unsigned long uninitialized_var(available_memory);
+	if (likely(battery_friend_active))
+	{
+	vm_dirty_ratio = 90;
+	}
+	else
+	{
+	vm_dirty_ratio = 70;
+	}
+
 	struct task_struct *tsk;
 
 	if (!vm_dirty_bytes || !dirty_background_bytes)
-- 
1.9.1

