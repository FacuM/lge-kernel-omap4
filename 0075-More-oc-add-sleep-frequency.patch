From 2df6d07d424c4739b8b6d8e12ca84849f6580d8b Mon Sep 17 00:00:00 2001
From: artas182x <artas182x@gmail.com>
Date: Sat, 12 Jul 2014 19:50:52 +0200
Subject: [PATCH 075/100] More oc - add sleep frequency

---
 arch/arm/mach-omap2/omap2plus-cpufreq.c | 137 ++++++++++++++++++++++++++++++++
 arch/arm/mach-omap2/opp4xxx_data.c      |   6 +-
 2 files changed, 140 insertions(+), 3 deletions(-)

diff --git a/arch/arm/mach-omap2/omap2plus-cpufreq.c b/arch/arm/mach-omap2/omap2plus-cpufreq.c
index c4178ae..77e5924 100644
--- a/arch/arm/mach-omap2/omap2plus-cpufreq.c
+++ b/arch/arm/mach-omap2/omap2plus-cpufreq.c
@@ -30,6 +30,7 @@
 #include <linux/thermal_framework.h>
 #include <linux/platform_device.h>
 #include <linux/omap4_duty_cycle.h>
+#include <linux/earlysuspend.h>
 
 #include <asm/system.h>
 #include <asm/smp_plat.h>
@@ -71,6 +72,24 @@ static unsigned int current_cooling_level;
 static bool omap_cpufreq_ready;
 static bool omap_cpufreq_suspended;
 
+
+#define CONFIG_OMAP4430_CPU_OVERCLOCK
+#ifdef CONFIG_OMAP4430_CPU_OVERCLOCK
+
+#include "smartreflex.h"
+
+#define OMAP4430_CPU_DEFAULT_MIN_FREQUENCY	200000
+#define OMAP4430_CPU_DEFAULT_MAX_FREQUENCY	1008000
+
+#endif
+
+#define ENABLE_SLEEP_MAX_FREQUENCY
+
+#ifdef ENABLE_SLEEP_MAX_FREQUENCY
+static unsigned int screen_off_max_freq = 0;
+static unsigned int max_freq_cap = 0;
+#endif
+
 static unsigned int omap_getspeed(unsigned int cpu)
 {
 	unsigned long rate;
@@ -128,6 +147,11 @@ static int omap_cpufreq_scale(unsigned int target_freq, unsigned int cur_freq)
 	 */
 	if (freqs.new > max_thermal)
 		freqs.new = max_thermal;
+  
+#ifdef ENABLE_SLEEP_MAX_FREQUENCY
+	if (max_freq_cap && freqs.new > max_freq_cap)
+		freqs.new = max_freq_cap;
+#endif
 
 	if ((freqs.old == freqs.new) && (cur_freq = freqs.new))
 		return 0;
@@ -450,7 +474,13 @@ static int __cpuinit omap_cpu_init(struct cpufreq_policy *policy)
 	cpufreq_frequency_table_get_attr(freq_table, policy->cpu);
 
 	policy->min = policy->cpuinfo.min_freq;
+#ifdef CONFIG_OMAP4430_CPU_OVERCLOCK
+	policy->min = OMAP4430_CPU_DEFAULT_MIN_FREQUENCY;
+	policy->max = OMAP4430_CPU_DEFAULT_MAX_FREQUENCY;
+#else  
+	policy->min = policy->cpuinfo.min_freq;
 	policy->max = policy->cpuinfo.max_freq;
+#endif
 	policy->cur = omap_getspeed(policy->cpu);
 
 	for (i = 0; freq_table[i].frequency != CPUFREQ_TABLE_END; i++)
@@ -471,6 +501,7 @@ static int __cpuinit omap_cpu_init(struct cpufreq_policy *policy)
 	/* FIXME: what's the actual transition time? */
 	policy->cpuinfo.transition_latency = 300 * 1000;
 
+
 	return 0;
 
 fail_table:
@@ -487,8 +518,105 @@ static int omap_cpu_exit(struct cpufreq_policy *policy)
 	return 0;
 }
 
+static void omap_cpu_early_suspend(struct early_suspend *h)
+{
+	unsigned int cur;
+
+	mutex_lock(&omap_cpufreq_lock);
+	max_freq_cap = screen_off_max_freq;
+		cur = omap_getspeed(0);
+		if (cur > max_freq_cap)
+			omap_cpufreq_scale(max_freq_cap, cur);
+
+
+
+	mutex_unlock(&omap_cpufreq_lock);
+}
+
+static void omap_cpu_late_resume(struct early_suspend *h)
+{
+	unsigned int cur;
+
+	mutex_lock(&omap_cpufreq_lock);
+	
+	if (max_freq_cap) {
+		max_freq_cap = 0;
+
+		cur = omap_getspeed(0);
+		if (cur != current_target_freq)
+			omap_cpufreq_scale(current_target_freq, cur);
+	}
+
+	mutex_unlock(&omap_cpufreq_lock);
+}
+
+static struct early_suspend omap_cpu_early_suspend_handler = {
+	.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN,
+	.suspend = omap_cpu_early_suspend,
+	.resume = omap_cpu_late_resume,
+};
+
+#ifdef ENABLE_SLEEP_MAX_FREQUENCY
+
+static ssize_t show_screen_off_freq(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%u\n", screen_off_max_freq);
+}
+
+static ssize_t store_screen_off_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	unsigned int freq = 0;
+	int ret;
+	int index;
+
+	if (!freq_table) return -EINVAL;
+
+	ret = sscanf(buf, "%u", &freq);
+	if (ret != 1) { 
+		screen_off_max_freq = 0;
+		return -EINVAL;
+	}
+
+	if ( ! freq ) {
+		screen_off_max_freq = 0;
+		pr_info("screen_off_max_freq limit removed\n");
+		return count;
+	}
+	mutex_lock(&omap_cpufreq_lock);
+
+	ret = cpufreq_frequency_table_target(policy, freq_table, freq, CPUFREQ_RELATION_H, &index);
+	if (ret) goto out;
+
+	screen_off_max_freq = freq_table[index].frequency;
+
+	pr_info("screen_off_max_freq set to: %u\n", screen_off_max_freq);
+
+	ret = count;
+
+out:
+	mutex_unlock(&omap_cpufreq_lock);
+	return ret;
+}
+
+struct freq_attr omap_cpufreq_attr_screen_off_freq = {
+	.attr = { .name = "screen_off_max_freq", .mode = 0644, },
+	.show = show_screen_off_freq,
+	.store = store_screen_off_freq,
+};
+
+#endif //ENABLE_SLEEP_MAX_FREQUENCY
+
+
+
+
+
+
+
 static struct freq_attr *omap_cpufreq_attr[] = {
 	&cpufreq_freq_attr_scaling_available_freqs,
+#ifdef ENABLE_SLEEP_MAX_FREQUENCY
+	&omap_cpufreq_attr_screen_off_freq,
+#endif
 	NULL,
 };
 
@@ -542,6 +670,12 @@ static int __init omap_cpufreq_init(void)
 {
 	int ret;
 
+#ifdef ENABLE_SLEEP_MAX_FREQUENCY
+	screen_off_max_freq = 0;
+	max_freq_cap = 0;
+#endif
+
+
 	if (cpu_is_omap24xx())
 		mpu_clk_name = "virt_prcm_set";
 	else if (cpu_is_omap34xx())
@@ -562,6 +696,8 @@ static int __init omap_cpufreq_init(void)
 		return -EINVAL;
 	}
 
+	register_early_suspend(&omap_cpu_early_suspend_handler);
+
 	ret = cpufreq_register_driver(&omap_driver);
 	omap_cpufreq_ready = !ret;
 
@@ -598,6 +734,7 @@ static void __exit omap_cpufreq_exit(void)
 	omap_cpufreq_cooling_exit();
 	omap_duty_cooling_exit();
 	cpufreq_unregister_driver(&omap_driver);
+	unregister_early_suspend(&omap_cpu_early_suspend_handler);
 	platform_driver_unregister(&omap_cpufreq_platform_driver);
 	platform_device_unregister(&omap_cpufreq_device);
 }
diff --git a/arch/arm/mach-omap2/opp4xxx_data.c b/arch/arm/mach-omap2/opp4xxx_data.c
index d880b9e..a771f71 100644
--- a/arch/arm/mach-omap2/opp4xxx_data.c
+++ b/arch/arm/mach-omap2/opp4xxx_data.c
@@ -181,7 +181,7 @@ struct omap_vdd_dep_info omap443x_vddiva_dep_info[] = {
 static struct omap_opp_def __initdata omap443x_opp_def_list[] = {
 	OPP_INITIALIZER("mpu", "dpll_mpu_ck", "mpu", true, 200000000, OMAP4430_VDD_MPU_OPP25_UV),
 	/* MPU OPP1 - OPP50 */
-	OPP_INITIALIZER("mpu", "dpll_mpu_ck", "mpu", true, 300000000, OMAP4430_VDD_MPU_OPP50_UV),
+	OPP_INITIALIZER("mpu", "dpll_mpu_ck", "mpu", true, 330000000, OMAP4430_VDD_MPU_OPP50_UV),
 	/* MPU OPP2 - OPP100 */
 	OPP_INITIALIZER("mpu", "dpll_mpu_ck", "mpu", true, 600000000, OMAP4430_VDD_MPU_OPP100_UV),
 	/* MPU OPP3 - OPP-Turbo */
@@ -189,8 +189,8 @@ static struct omap_opp_def __initdata omap443x_opp_def_list[] = {
 	/* MPU OPP4 - OPP-NT */
 	OPP_INITIALIZER("mpu", "dpll_mpu_ck", "mpu", true, 1008000000, OMAP4430_VDD_MPU_OPPNITRO_UV),
 	/* MPU OPP5 - OPP-SB */
-	OPP_INITIALIZER("mpu", "dpll_mpu_ck", "mpu", false, 1200000000, OMAP4430_VDD_MPU_OPPNITROSB_UV),
-	OPP_INITIALIZER("mpu", "dpll_mpu_ck", "mpu", false, 1350000000, OMAP4430_VDD_MPU_OPPNITROSB2_UV),
+	OPP_INITIALIZER("mpu", "dpll_mpu_ck", "mpu", true, 1200000000, OMAP4430_VDD_MPU_OPPNITROSB_UV),
+	OPP_INITIALIZER("mpu", "dpll_mpu_ck", "mpu", true, 1350000000, OMAP4430_VDD_MPU_OPPNITROSB2_UV),
 	/* L3 OPP1 - OPP50 */
 	OPP_INITIALIZER("l3_main_1", "virt_l3_ck", "core", true, 100000000, OMAP4430_VDD_CORE_OPP50_UV),
 	/* L3 OPP2 - OPP100, OPP-Turbo, OPP-SB */
-- 
1.9.1

