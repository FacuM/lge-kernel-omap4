diff a/mm/page-writeback.c b/mm/page-writeback.c	(rejected hunks)
@@ -35,6 +35,7 @@
 #include <linux/buffer_head.h>
 #include <linux/pagevec.h>
 #include <trace/events/writeback.h>
+#include <linux/earlysuspend.h>
 
 /*
  * After a CPU has dirtied this many pages, balance_dirty_pages_ratelimited
@@ -89,7 +90,7 @@ static inline long sync_writeback_pages(unsigned long dirtied)
 /*
  * The interval between `kupdate'-style writebacks
  */
-unsigned int dirty_writeback_interval = 15 * 100; /* centiseconds */
+unsigned int dirty_writeback_interval = 0; /* centiseconds */
 
 /*
  * The longest time for which data is allowed to remain dirty
@@ -772,6 +773,21 @@ void writeback_set_ratelimit(void)
 	.next		= NULL,
 };
 
+static void dirty_early_suspend(struct early_suspend *handler)
+{
+  dirty_writeback_interval = 15 * 100;
+}
+
+static void dirty_late_resume(struct early_suspend *handler)
+{
+  dirty_writeback_interval = 0;
+}
+
+static struct early_suspend dirty_suspend = {
+  .suspend = dirty_early_suspend,
+  .resume = dirty_late_resume,
+};
+ 
 /*
  * Called early on to tune the page writeback dirty limits.
  *
@@ -794,6 +810,7 @@ void __init page_writeback_init(void)
 {
 	int shift;
 
+	register_early_suspend(&dirty_suspend);
 	writeback_set_ratelimit();
 	register_cpu_notifier(&ratelimit_nb);
 
